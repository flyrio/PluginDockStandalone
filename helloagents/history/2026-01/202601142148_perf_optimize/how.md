# 方案名称: 启用即掉帧的性能优化

## 方案概述
围绕“每帧热路径”做减法：减少不必要的常驻执行、减少每帧分配与字符串/IO 操作、对高频且稳定的数据做短周期缓存。

### 当前方案（优化后）
- **窗口隐藏器（WindowHider）**
  - 当不存在任何隐藏目标时，直接跳过隐藏器逻辑（避免空转）
  - 移除按名称每帧调用 `ImGui.SetWindowPos/SetWindowCollapsed` 的路径，改为仅使用“硬隐藏”对 ImGuiWindow 进行标记与清空绘制命令
  - 避免 `ToArray()` 等每帧分配

- **Dock 渲染**
  - 缓存已加载插件列表与按 InternalName 索引字典，短周期刷新，避免每帧 `InstalledPlugins.Where/OrderBy/ToDictionary`
  - 复用临时列表，减少每帧分配

- **图标加载**
  - 优先命中已加载纹理缓存，避免每帧重复 `File.Exists`

### 备选方案（未采用）
- 通过降低隐藏器执行频率来换取性能（存在窗口短暂显示风险）
- 引入更复杂的变更监听（需要额外依赖或反射，风险与维护成本更高）

## 方案流程图
```mermaid
flowchart TD
    A[UiBuilder.Draw] --> B{是否存在隐藏目标/待处理任务}
    B -- 否 --> C[快速返回(仅必要绘制)]
    B -- 是 --> D[执行隐藏器硬隐藏/处理队列]
    D --> E[窗口系统绘制(仅打开的窗口)]
```

## 方案 ADR
无需新增 ADR（不引入新模块/新技术栈，仅做内部性能优化与缓存）。

## API 变更
- 无

## 数据变更
- 无（仅新增运行期缓存字段）

## 兼容性
- 与现有配置完全兼容
- 缓存刷新存在秒级延迟，但不影响核心行为

## 回滚方案
- 恢复隐藏器按名称每帧 `SetWindowPos/SetWindowCollapsed` 的旧逻辑
- 移除插件列表缓存，恢复每帧实时枚举

